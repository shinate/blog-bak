<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>codante</title>
    <description></description>
    <link>http://codante.org/blog/</link>
    <atom:link href="http://codante.org/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 16 Jun 2016 15:26:39 +0800</pubDate>
    <lastBuildDate>Thu, 16 Jun 2016 15:26:39 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>检测移动设备及鼠标/触摸事件兼容</title>
        <description>&lt;p&gt;&lt;strong&gt;MAC触摸板也支持touch，加入了区分判断&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;(function () {
        // IOS desktop has touch events, make them busting
        var hasTouch = !!((&amp;#39;ontouchstart&amp;#39; in global &amp;amp;&amp;amp; !/Mac OS X /.test(global.navigator.userAgent)) || global.DocumentTouch &amp;amp;&amp;amp; document instanceof global.DocumentTouch);
        return {
            hasTouch: hasTouch,
            startEvt: hasTouch ? &amp;#39;touchstart&amp;#39; : &amp;#39;mousedown&amp;#39;,
            moveEvt: hasTouch ? &amp;#39;touchmove&amp;#39; : &amp;#39;mousemove&amp;#39;,
            endEvt: hasTouch ? &amp;#39;touchend&amp;#39; : &amp;#39;mouseup&amp;#39;,
            cancelEvt: hasTouch ? &amp;#39;touchcancel&amp;#39; : &amp;#39;mouseout&amp;#39;,
            resizeEvt: &amp;#39;onorientationchange&amp;#39; in global ? &amp;#39;orientationchange&amp;#39; : &amp;#39;resize&amp;#39;
        };
    })();
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Thu, 16 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://codante.org/blog/2016/06/16/detecting-mobile-device-event.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2016/06/16/detecting-mobile-device-event.html</guid>
        
        
      </item>
    
      <item>
        <title>移动端前端调试工具</title>
        <description>&lt;h1&gt;weinre&lt;/h1&gt;

&lt;h2&gt;安装&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;npm install -g weinre
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;启动&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;wernre --boundHost [IP] --httpPort [PORT]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;进入相应网址，按提示配置及访问&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://codante.org/blog/2016/03/07/mobile-terminal-debugging.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2016/03/07/mobile-terminal-debugging.html</guid>
        
        
      </item>
    
      <item>
        <title>在命令行让MAC说话唱歌</title>
        <description>&lt;h2&gt;调用say&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;/usr/bin/say 那啥那啥啥
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;参数&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# -v 选择声音，默认是Siri(say -v Samantha)
# -o 输出为音频文件，(say -v Cellos -o &amp;quot;xxx.m4a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;写脚本的时候为了兼容linux系统，可以包个方法&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;function VT (){
    if [[ (-f /usr/bin/say) &amp;amp;&amp;amp; (-n &amp;quot;${1}&amp;quot;) ]]; then
        /usr/bin/say &amp;quot;${1}&amp;quot;
    fi
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Mon, 07 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://codante.org/blog/2016/03/07/let-mac-speak.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2016/03/07/let-mac-speak.html</guid>
        
        
      </item>
    
      <item>
        <title>进制转换与位移运算</title>
        <description>&lt;h1&gt;进制转换&lt;/h1&gt;

&lt;h2&gt;二进制 &amp;gt;&amp;gt; 十进制&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;1101(2) = 1*2^0 + 0*2^1 + 1*2^2 + 1*2^3 = 1 + 0 + 4 + 8 = 13
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;八进制 &amp;gt;&amp;gt; 十进制&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;1101(8) = 1*8^0 + 0*8^1 + 1*8^2 + 1*8^3 = 1+0+64+512 = 577
425(8) = 5*8^0 + 2*8^1 + 4*8^2 = 5 + 16 + 256 = 277
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;十六进制 &amp;gt;&amp;gt; 十进制&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;1101(16)= 1*16^0 + 0*16^1 + 1*16^2 + 1*16^3 = 1 + 256 + 4096 = 4353
AF(16) = 15*16^0 + 10*16^1 = 15 + 160 = 175
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;二进制 &amp;gt;&amp;gt; 八进制&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;1100100(2) = [001 100 100](2) = [1 4 4](8) = 144(8)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;二进制 &amp;gt;&amp;gt; 十六进制&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;10001001101010111100110111101111(2) = [1000 1001 1010 1011 1100 1101 1110 1111](2) = [8 9 A B C D E F](16) = 89ABCDEF(16) = 0x89ABCDEF
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;十进制 &amp;gt;&amp;gt; 二进制&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;整数位按照除2取余的规则进行换算
25除以2    12余1
12除以2    6余0
6除以2     3余0
3除以2     1余1
1除以2     0余1

4的二进制为100, 2等于10

18(10) = 4*4+2 = 10000 + 10 = 10010(2)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;十进制 &amp;gt;&amp;gt; 二进制 (小数)&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;求25.8125的二进制

整数位
25(10) = 11001(2)

小数位十进制0.8125，按照乘2取整的规则，小数部分继续乘以2，取整，得到小数部分0为止，将整数顺序排列
0.8125x2=1.625   取整1
0.625x2=1.25     取整1
0.25x2=0.5       取整0
0.5x2=1.0        取整1
0                结束

0.8125(10) = 0.1101(2)

25.8125(10) = 11001.1101(2)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;位移操作&lt;/h2&gt;

&lt;p&gt;To bi continue...&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://codante.org/blog/2016/02/19/hexadecimal.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2016/02/19/hexadecimal.html</guid>
        
        
      </item>
    
      <item>
        <title>Shell if</title>
        <description>&lt;h2&gt;字符串判断&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;str1 = str2　　　　　　当两个串有相同内容、长度时为真 
str1 != str2　　　　　 当串str1和str2不等时为真 
-n str1　　　　　　　  当串的长度大于0时为真(串非空) 
-z str1　　　　　　　  当串的长度为0时为真(空串) 
str1　　　　　　　　   当串str1为非空时为真
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;数字的判断&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;int1 -eq int2　　　　两数相等为真 
int1 -ne int2　　　　两数不等为真 
int1 -gt int2　　　　int1大于int2为真 
int1 -ge int2　　　　int1大于等于int2为真 
int1 -lt int2　　　　int1小于int2为真 
int1 -le int2　　　　int1小于等于int2为真
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;文件的判断&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;-r file　　　　　用户可读为真 
-w file　　　　　用户可写为真 
-x file　　　　　用户可执行为真 
-f file　　　　　文件为正规文件为真 
-d file　　　　　文件为目录为真 
-c file　　　　　文件为字符特殊文件为真 
-b file　　　　　文件为块特殊文件为真 
-s file　　　　　文件大小非0时为真 
-t file　　　　　当文件描述符(默认为1)指定的设备为终端时为真
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;复杂逻辑判断&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;-a 　 　　　　　 与 
-o　　　　　　　 或 
!　　　　　　　　非
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Thu, 21 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://codante.org/blog/2016/01/21/shell-if.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2016/01/21/shell-if.html</guid>
        
        
      </item>
    
      <item>
        <title>Mac系统用bash shell用默认浏览器打开网址</title>
        <description>&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;open http://codante.org -a &amp;quot;$(VERSIONER_PERL_PREFER_32_BIT=true perl -MMac::InternetConfig -le &amp;#39;print +(GetICHelper &amp;quot;http&amp;quot;)[1]&amp;#39;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Thu, 21 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://codante.org/blog/2016/01/21/bash-shell-open-default-web-browser-on-mac.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2016/01/21/bash-shell-open-default-web-browser-on-mac.html</guid>
        
        
      </item>
    
      <item>
        <title>Git 配置及指令</title>
        <description>&lt;h2&gt;新建代码库&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 在当前目录新建一个Git代码库
$ git init
# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]
# 下载一个项目和它的整个代码历史
$ git clone [url]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;配置&lt;/h2&gt;

&lt;p&gt;Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 显示当前的Git配置
$ git config -l [--local]
# 编辑Git配置文件
$ git config -e [--global]
# 设置提交代码时的用户信息
$ git config [--local] user.name &amp;quot;[name]&amp;quot;
$ git config [--lcoal] user.email &amp;quot;[email address]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;增加/删除文件&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 添加指定文件到暂存区
$ git add [file1] [file2] ...
# 添加指定目录到暂存区，包括子目录
$ git add [dir]
# 添加当前目录的所有文件到暂存区
$ git add .
# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...
# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]
# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;代码提交&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 提交暂存区到仓库区
$ git commit -m [message]
# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]
# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a
# 提交时显示所有diff信息
$ git commit -v
# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]
# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;分支&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 列出所有本地分支
$ git branch
# 列出所有远程分支
$ git branch -r
# 列出所有本地分支和远程分支
$ git branch -a
# 列出所有本地分支及其与远端分支的追踪关系
$ git branch -vv
# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]
# 新建一个分支，并切换到该分支
$ git checkout -b [branch]
# 新建一个分支，指向指定commit
$ git branch [branch] [commit]
# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]
# 切换到指定分支，并更新工作区
$ git checkout [branch-name]
# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]
# 合并指定分支到当前分支
$ git merge [branch]
# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]
# 删除分支
$ git branch -d [branch-name]
# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;标签&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 列出所有tag
$ git tag
# 新建一个tag在当前commit
$ git tag [tag]
# 新建一个tag在指定commit
$ git tag [tag] [commit]
# 查看tag信息
$ git show [tag]
# 提交指定tag
$ git push [remote] [tag]
# 提交所有tag
$ git push [remote] --tags
# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;查看信息&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 显示有变更的文件
$ git status
# 显示当前分支的版本历史
$ git log
# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat
# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]
# 显示指定文件相关的每一次diff
$ git log -p [file]
# 显示指定文件是什么人在什么时间修改过
$ git blame [file]
# 显示暂存区和工作区的差异
$ git diff
# 显示暂存区和上一个commit的差异
$ git diff --cached [file]
# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD
# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]
# 显示某次提交的元数据和内容变化
$ git show [commit]
# 显示某次提交发生变化的文件
$ git show --name-only [commit]
# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]
# 显示当前分支的最近几次提交
$ git reflog
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;远程同步&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 下载远程仓库的所有变动
$ git fetch [remote]
# 显示所有远程仓库
$ git remote -v
# 显示某个远程仓库的信息
$ git remote show [remote]
# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]
# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]
# 上传本地指定分支到远程仓库
$ git push [remote] [branch]
# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force
# 推送所有分支到远程仓库
$ git push [remote] --all
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;撤销&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 恢复暂存区的指定文件到工作区
$ git checkout [file]
# 恢复某个commit的指定文件到工作区
$ git checkout [commit] [file]
# 恢复上一个commit的所有文件到工作区
$ git checkout .
# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]
# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard
# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]
# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]
# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]
# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;submodule&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;# 添加一个submodule
$ git submodule add [url] [dir]
# 初始化
$ git submodule init [dir]
# 更新
$ git submodule update [dir]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;克隆一个带有submodule的远程代码仓库&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ git clone [url]
$ git submodule init
$ git submodule update
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ git clone --recursive [url]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/docs&quot;&gt;git官方doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot;&gt;常用Git命令清单 by ruanyifeng&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 15 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://codante.org/blog/2015/12/15/git-configuration-commands.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2015/12/15/git-configuration-commands.html</guid>
        
        
      </item>
    
      <item>
        <title>Blender 3D 技巧收集</title>
        <description>&lt;h3&gt;Modifiers cannot be applied to multi-user data&lt;/h3&gt;

&lt;p&gt;Press U &amp;gt; Objects and Data. Then apply your modifier. Using just Object will make the object a new, separate datablock for the mesh (but will ignore modifiers). However, using Object and Data will make both the objects mesh and it&amp;#39;s modifiers a new, separate datablock.&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://codante.org/blog/2015/12/10/blender-skill.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2015/12/10/blender-skill.html</guid>
        
        
      </item>
    
      <item>
        <title>设计模式</title>
        <description>&lt;h2&gt;创建型&lt;/h2&gt;

&lt;h3&gt;Factory Method（工厂方法）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/699ef9c0jw1ey69scmmiaj20eo050jrp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;当一个类不知道它所必须创建的对象的类的时候。&lt;/p&gt;

&lt;p&gt;当一个类希望由它的子类来指定它所创建的对象的时候。&lt;/p&gt;

&lt;p&gt;当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。&lt;/p&gt;

&lt;h3&gt;Abstract Factory（抽象工厂）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/699ef9c0jw1ey699h2iq8j20fw077gm9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;一个系统要独立于它的产品的创建、组合和表示时。&lt;/p&gt;

&lt;p&gt;一个系统要由多个产品系列中的一个来配置时。&lt;/p&gt;

&lt;p&gt;当你要强调一系列相关的产品对象的设计以便进行联合使用时。&lt;/p&gt;

&lt;p&gt;当你提供一个产品类库，而只想显示它们的接口而不是实现时。&lt;/p&gt;

&lt;h3&gt;Builder（建造者）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/699ef9c0jw1ey69xu3hijj20fb05a74h.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。&lt;/p&gt;

&lt;p&gt;当构造过程必须允许被构造的对象有不同的表示时。&lt;/p&gt;

&lt;h3&gt;Prototype（原型）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/699ef9c0jw1ey69ydhs0jj20dr06cwes.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者&lt;/p&gt;

&lt;p&gt;为了避免创建一个与产品类层次平行的工厂类层次时；或者&lt;/p&gt;

&lt;p&gt;当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。&lt;/p&gt;

&lt;h3&gt;Singleton（单例）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/699ef9c0jw1ey69zvor67j20az03u0st.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。&lt;/p&gt;

&lt;p&gt;当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。&lt;/p&gt;

&lt;h2&gt;结构型&lt;/h2&gt;

&lt;h3&gt;Adapter Class/Object（适配器）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/699ef9c0jw1ey6a0dj8smj20ed0an3z2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;你想使用一个已经存在的类，而它的接口不符合你的需求。&lt;/p&gt;

&lt;p&gt;你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。&lt;/p&gt;

&lt;p&gt;（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。&lt;/p&gt;

&lt;h3&gt;Bridge（桥接）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/699ef9c0jw1ey6a0vnhksj20fe067wes.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;将抽象部分与它的实现部分分离，使它们都可以独立地变化。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。&lt;/p&gt;

&lt;p&gt;类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。&lt;/p&gt;

&lt;p&gt;对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。&lt;/p&gt;

&lt;p&gt;（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。&lt;/p&gt;

&lt;p&gt;有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh 称这种类层次结构为“嵌套的普化”（nested generalizations）。&lt;/p&gt;

&lt;p&gt;你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String 类，在这个类中多个对象可以共享同一个字符串表示（StringRep）。&lt;/p&gt;

&lt;h3&gt;Composite（组合）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/699ef9c0jw1ey6a1znrvmj20fb06ut93.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;你想表示对象的部分-整体层次结构。&lt;/p&gt;

&lt;p&gt;你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/699ef9c0jw1ey6a6mopmxj20fd06sq3d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。&lt;/p&gt;

&lt;p&gt;处理那些可以撤消的职责。&lt;/p&gt;

&lt;p&gt;当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。&lt;/p&gt;

&lt;h3&gt;Facade（外观）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/699ef9c0jw1ey6a78rls0j20d7054q32.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。&lt;/p&gt;

&lt;p&gt;客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。&lt;/p&gt;

&lt;p&gt;当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。&lt;/p&gt;

&lt;h3&gt;Flyweight（享元）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/699ef9c0jw1ey6a7pbw4dj20ft09xaaq.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;运用共享技术有效地支持大量细粒度的对象。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;一个应用程序使用了大量的对象。&lt;/p&gt;

&lt;p&gt;完全由于使用大量的对象，造成很大的存储开销。&lt;/p&gt;

&lt;p&gt;对象的大多数状态都可变为外部状态。&lt;/p&gt;

&lt;p&gt;如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。&lt;/p&gt;

&lt;p&gt;应用程序不依赖于对象标识。由于Flyweight 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。&lt;/p&gt;

&lt;h3&gt;Proxy（代理）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/699ef9c0jw1ey6a9bnfsjj20du05ht8u.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一 些可以使用Proxy 模式常见情况：
1. 远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表。 NEXTSTEP使用NXProxy 类实现了这一目的。Coplien称这种代理为“大使” （Ambassador）。
2. 虚代理（Virtual Proxy）根据需要创建开销很大的对象。在动机一节描述的ImageProxy 就是这样一种代理的例子。
3. 保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。例如，在Choices 操作系统中KemelProxies为操作系统对象提供 了访问保护。
4. 智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。 它的典型用途包括：&lt;/p&gt;

&lt;p&gt;对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它（也称为SmartPointers）。&lt;/p&gt;

&lt;p&gt;当第一次引用一个持久对象时，将它装入内存。&lt;/p&gt;

&lt;p&gt;在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。&lt;/p&gt;

&lt;h2&gt;行为型&lt;/h2&gt;

&lt;h3&gt;Interpreter（解释器）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/699ef9c0jw1ey6a85310dj20bw068jrn.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：&lt;/p&gt;

&lt;p&gt;该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。&lt;/p&gt;

&lt;p&gt;效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下，转换器仍可用解释器模式实现，该模式仍是有用的。&lt;/p&gt;

&lt;h3&gt;Template Method（模板方法）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/699ef9c0jw1ey6a9tl0h2j20ad05zweo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。&lt;/p&gt;

&lt;p&gt;各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke 和Johnson 所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。&lt;/p&gt;

&lt;p&gt;控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。&lt;/p&gt;

&lt;h3&gt;Chain of Responsibility（责任链）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/699ef9c0jw1ey6abfcf5vj20aa0560su.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。&lt;/p&gt;

&lt;p&gt;你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。&lt;/p&gt;

&lt;p&gt;可处理一个请求的对象集合应被动态指定。&lt;/p&gt;

&lt;h3&gt;Command（命令）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/699ef9c0jw1ey6abppgarj20fe04u74i.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（call back）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command 模式是回调机制的一个面向对象的替代品。&lt;/p&gt;

&lt;p&gt;在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。&lt;/p&gt;

&lt;p&gt;支持取消操作。Command的Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command 接口必须添加一个Unexecute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。&lt;/p&gt;

&lt;p&gt;支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。&lt;/p&gt;

&lt;p&gt;用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务（transaction）的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。&lt;/p&gt;

&lt;h3&gt;Iterator（迭代器）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/699ef9c0jw1ey6ac8tkioj20ek06qmxh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;访问一个聚合对象的内容而无需暴露它的内部表示。&lt;/p&gt;

&lt;p&gt;支持对聚合对象的多种遍历。&lt;/p&gt;

&lt;p&gt;为遍历不同的聚合结构提供一个统一的接口（即，支持多态迭代）。&lt;/p&gt;

&lt;h3&gt;Mediator（中介者）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/699ef9c0jw1ey6acknpu0j20dz03rdfx.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。&lt;/p&gt;

&lt;p&gt;一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。&lt;/p&gt;

&lt;p&gt;想定制一个分布在多个类中的行为，而又不想生成太多的子类。&lt;/p&gt;

&lt;h3&gt;Memento（备忘录）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/699ef9c0jw1ey6acxk2jij20f104faab.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。&lt;/p&gt;

&lt;p&gt;如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。&lt;/p&gt;

&lt;h3&gt;Observer（观察者）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/699ef9c0jw1ey6ad7vvbsj20fe05pt98.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。&lt;/p&gt;

&lt;p&gt;当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。&lt;/p&gt;

&lt;p&gt;当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。&lt;/p&gt;

&lt;h3&gt;State（状态）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/699ef9c0jw1ey6adna8v1j20ck04njri.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。&lt;/p&gt;

&lt;p&gt;一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。&lt;/p&gt;

&lt;h3&gt;Strategy（策略）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/699ef9c0jw1ey6adz59bqj20el04o74k.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。&lt;/p&gt;

&lt;p&gt;需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。&lt;/p&gt;

&lt;p&gt;算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。&lt;/p&gt;

&lt;p&gt;一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。&lt;/p&gt;

&lt;h3&gt;Visitor（访问者）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/699ef9c0jw1ey6aedb8whj20ad05x74i.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;意图：&lt;/h4&gt;

&lt;p&gt;定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;

&lt;h4&gt;适用性：&lt;/h4&gt;

&lt;p&gt;一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。&lt;/p&gt;

&lt;p&gt;各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。&lt;/p&gt;

&lt;p&gt;控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://codante.org/blog/2015/11/19/design-pattern.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2015/11/19/design-pattern.html</guid>
        
        
      </item>
    
      <item>
        <title>redis安装及配置</title>
        <description>&lt;h2&gt;依赖&lt;/h2&gt;

&lt;p&gt;安装redis需要先安装tcl
&lt;a href=&quot;http://www.linuxfromscratch.org/blfs/view/cvs/general/tcl.html&quot; title=&quot;tcl&quot;&gt;http://www.linuxfromscratch.org/blfs/view/cvs/general/tcl.html&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;获取软件&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;#tcl8.5
wget http://downloads.sourceforge.net/tcl/tcl8.5.12-src.tar.gz
#redis
wget http://redis.googlecode.com/files/redis-2.6.2.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;安装&lt;/h2&gt;

&lt;h3&gt;tcl&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;tar -zxf tcl8.5.12-html.tar.gz --strip-components=1
cd unix &amp;amp;&amp;amp; ./configure --prefix=/usr \
--enable-threads \
--mandir=/usr/share/man
make
sed -e &amp;quot;s@^\(TCL_SRC_DIR=&amp;#39;\).*@/usr/include&amp;#39;@&amp;quot; \
-e &amp;quot;/TCL_B/s@=&amp;#39;\(-L\)\?.*unix@=&amp;#39;/usr/lib@&amp;quot; \
-i tclConfig.sh
make install
make install-private-headers
ln -v -sf tclsh8.5 /usr/bin/tclsh
chmod -v 755 /usr/lib/libtcl8.5.so
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Wed, 31 Oct 2012 11:13:11 +0800</pubDate>
        <link>http://codante.org/blog/2012/10/31/redis-install-and-configure.html</link>
        <guid isPermaLink="true">http://codante.org/blog/2012/10/31/redis-install-and-configure.html</guid>
        
        
      </item>
    
  </channel>
</rss>
